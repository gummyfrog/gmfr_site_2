"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSpectrumAnalyzer = function (bufferSize) {
    var real = new Float64Array(bufferSize);
    var imag = new Float64Array(bufferSize);
    var reverseTable = new Uint32Array(bufferSize);
    var limit = 1;
    var bit = bufferSize >> 1;
    while (limit < bufferSize) {
        for (var i = 0; i < limit; i++) {
            reverseTable[i + limit] = reverseTable[i] + bit;
        }
        limit = limit << 1;
        bit = bit >> 1;
    }
    var sinTable = new Float64Array(bufferSize);
    var cosTable = new Float64Array(bufferSize);
    for (var i = 0; i < bufferSize; i++) {
        sinTable[i] = Math.sin(-Math.PI / i);
        cosTable[i] = Math.cos(-Math.PI / i);
    }
    var calculateSpectrum = function () {
        var spectrum = new Array(bufferSize / 2);
        var bSi = 2 / bufferSize;
        for (var i = 0, N = bufferSize / 2; i < N; i++) {
            var rval = real[i];
            var ival = imag[i];
            var mag = bSi * Math.sqrt(rval * rval + ival * ival);
            spectrum[i] = mag;
        }
        return spectrum;
    };
    return function (buffer) {
        var k = Math.floor(Math.log(bufferSize) / Math.LN2);
        if (Math.pow(2, k) !== bufferSize) {
            throw new Error('Invalid buffer size, must be a power of 2');
        }
        if (bufferSize !== buffer.length) {
            throw new Error("Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length);
        }
        var halfSize = 1;
        for (var i = 0; i < bufferSize; i++) {
            real[i] = buffer[reverseTable[i]];
            imag[i] = 0;
        }
        while (halfSize < bufferSize) {
            var phaseShiftStepReal = cosTable[halfSize];
            var phaseShiftStepImag = sinTable[halfSize];
            var currentPhaseShiftReal = 1;
            var currentPhaseShiftImag = 0;
            for (var fftStep = 0; fftStep < halfSize; fftStep++) {
                var i = fftStep;
                while (i < bufferSize) {
                    var off = i + halfSize;
                    var tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
                    var ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);
                    real[off] = real[i] - tr;
                    imag[off] = imag[i] - ti;
                    real[i] += tr;
                    imag[i] += ti;
                    i += halfSize << 1;
                }
                var tmpReal = currentPhaseShiftReal;
                currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
                currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
            }
            halfSize = halfSize << 1;
        }
        return calculateSpectrum();
    };
};
//# sourceMappingURL=spectrum.js.map