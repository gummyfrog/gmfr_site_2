"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var ffmpeg_static_1 = __importDefault(require("ffmpeg-static"));
var dsp_1 = require("./dsp");
exports.skipEvery = function (skipIndex) { return function (element, index) {
    return index % skipIndex === 0;
}; };
exports.getPeaks = function (spectrums, prevPeaks) {
    if (!prevPeaks) {
        return spectrums;
    }
    var resultPeaks = [];
    for (var i = 0; i < spectrums.length; i++) {
        var currValue = spectrums[i];
        var currPrevPeak = prevPeaks[i] || 0;
        resultPeaks.push((currValue > currPrevPeak) ? currValue : currPrevPeak);
    }
    return resultPeaks;
};
exports.correctPeaks = function (spectrums, peaks) {
    var resultSpectrum = [];
    for (var i = 0; i < spectrums.length; i++) {
        var value = spectrums[i];
        var peakValue = peaks[i] || 0;
        if (value < 3) {
            resultSpectrum.push(value / 3);
        }
        else {
            resultSpectrum.push(value / peakValue);
        }
    }
    return resultSpectrum;
};
exports.smoothValues = function (spectrums, prevSpectrums) {
    if (!prevSpectrums) {
        return spectrums;
    }
    var resultSpectrum = [];
    for (var i = 0; i < spectrums.length; i++) {
        var currValue = spectrums[i];
        var currPrevValue = prevSpectrums[i] || 0;
        var avgValue = (currValue + currPrevValue) / 2;
        resultSpectrum.push(avgValue);
    }
    return resultSpectrum;
};
exports.createSpectrumsProcessor = function (busesCount) {
    var prevAudioDataNormalized = [];
    var prevPeaks = [];
    var prevSpectrums = [];
    var skipFrameIndex = 2;
    return function (frameIndex, parseAudioData) {
        var isFrameSkiped = frameIndex && (frameIndex % skipFrameIndex === 0);
        var audioDataNomrmalized = isFrameSkiped ?
            prevAudioDataNormalized :
            exports.normalizeAudioData(parseAudioData());
        prevAudioDataNormalized = audioDataNomrmalized;
        var spectrum = dsp_1.getSpectrum(audioDataNomrmalized);
        var skipIndex = Math.trunc(spectrum.length / busesCount);
        var spectrumReduced = spectrum.filter(exports.skipEvery(skipIndex));
        var peaks = exports.getPeaks(spectrumReduced, prevPeaks);
        var correctedSpectrum = exports.correctPeaks(spectrumReduced, peaks);
        var smoothSpectrum = exports.smoothValues(correctedSpectrum, prevSpectrums);
        prevSpectrums = smoothSpectrum;
        prevPeaks = peaks;
        return smoothSpectrum;
    };
};
exports.bufferToUInt8 = function (buffer, start, end) {
    var numbers = [];
    for (var i = start; i < end; i += 1) {
        numbers.push(buffer.readUInt8(i));
    }
    return numbers;
};
exports.normalizeAudioData = function (PCMData) {
    return PCMData.map(function (num) { return (num - 128) / 128; });
};
exports.spawnFfmpegAudioReader = function (filename, format) {
    var ffmpegProcess = child_process_1.spawn(ffmpeg_static_1.default.path, ['-i', filename, '-f', format, '-ac', '1', '-']);
    return ffmpegProcess;
};
exports.createAudioBuffer = function (filename, format) {
    return new Promise(function (resolve, reject) {
        var sampleRate;
        var sampleRateRegExp = /(\d+) Hz/m;
        var audioBuffers = [];
        var ffmpegAudioReader = exports.spawnFfmpegAudioReader(filename, format);
        ffmpegAudioReader.stderr.on('data', function (data) {
            var match = data.toString().match(sampleRateRegExp);
            if (!sampleRate && match) {
                sampleRate = match[1];
            }
        });
        ffmpegAudioReader.stdout.on('data', function (chunkBuffer) {
            audioBuffers.push(chunkBuffer);
        });
        ffmpegAudioReader.stdout.on('end', function () {
            var audioBuffer = Buffer.concat(audioBuffers);
            resolve({ audioBuffer: audioBuffer, sampleRate: sampleRate });
        });
    });
};
//# sourceMappingURL=audio.js.map